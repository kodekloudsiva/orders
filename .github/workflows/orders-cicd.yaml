name: Orders CI/CD Pipeline

on:
  push:
    branches-ignore:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  # ---------------------------------
  # 1. Unit Tests + Coverage
  # ---------------------------------
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'
      - run: dotnet restore
      - run: sudo apt-get update && sudo apt-get install -y bc libxml2-utils

      - name: Run unit tests with coverage
        run: |
          dotnet test ./orders.test/orders.test.csproj \
            --collect:"XPlat Code Coverage" \
            --results-directory ./TestResults \
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura \
            -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Include="[orders.domain]*,[orders.application]*"

      - name: Install ReportGenerator
        run: |
          dotnet tool install --global dotnet-reportgenerator-globaltool
          echo "${HOME}/.dotnet/tools" >> $GITHUB_PATH

      - name: Generate coverage report
        run: |
          reportgenerator -reports:./TestResults/**/coverage.cobertura.xml \
            -targetdir:CoverageReport \
            "-reporttypes:Html;TextSummary;HtmlSummary;Cobertura;XmlSummary"

      - name: Validate 65% code coverage threshold
        run: |
          COVERAGE_FILE=$(find CoverageReport -name 'Summary.xml')
          COVERAGE_PERCENT=$(xmllint --xpath "string(//Summary/Linecoverage)" "$COVERAGE_FILE")
          echo "✅ Code coverage: $COVERAGE_PERCENT%"
          if echo "$COVERAGE_PERCENT < 65" | bc -l | grep -q 1; then
            echo "❌ Code coverage below threshold!"
            exit 1
          fi

      # ✅ Upload report artifact only on main/master *and only for push*
      - uses: actions/upload-artifact@v4
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
        with:
          name: code-coverage-report
          path: CoverageReport/

  # ---------------------------------
  # 2. DB Migration (push to main/master only)
  # ---------------------------------
  db-generate-migrations:
    needs: unit-tests
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest
    outputs:
      has_migrations: ${{ steps.migrations.outputs.has_migrations }}
    steps:
      - uses: actions/checkout@v4

      # ---------------------------------
      # Install EF Core Tools + Build Solution
      # ---------------------------------
      - name: Install EF Core tools
        run: dotnet tool install --global dotnet-ef

      - name: Add .NET tools to PATH
        run: echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

      - name: Restore dependencies
        run: dotnet restore ./orders.service.sln

      - name: Build solution
        run: dotnet build ./orders.service.sln --configuration Release --no-restore

      # ---------------------------------
      # Check for EF Core migrations
      # ---------------------------------
      - name: Get migrations
        id: migrations
        env: 
          ConnectionStrings__DefaultConnection: "Server=DummyServer;Database=DummyDb;User Id=sa;Password=DummyPassword;"
        run: |
          echo "📋 Checking EF Core migrations..."
          MIGRATIONS=$(dotnet ef migrations list \
            --project orders.database \
            --startup-project orders.webapi \
            --configuration Release \
            --context OrderDbContext \
            --no-build --no-connect 2>&1 \
            | grep -E '^[0-9]{14}_.+' || true)

          echo "MIGRATIONS FOUND:"
          echo "$MIGRATIONS"

          if [[ -z "$MIGRATIONS" || "$MIGRATIONS" == "No migrations were found." ]]; then
            echo "has_migrations=false" >> $GITHUB_OUTPUT
          else
            LAST_MIGRATION=$(echo "$MIGRATIONS" | tail -n 1)
            PREVIOUS_MIGRATION=$(echo "$MIGRATIONS" | tail -n 2 | head -n 1)

            echo "has_migrations=true" >> $GITHUB_OUTPUT
            echo "LAST_MIGRATION=$LAST_MIGRATION" >> $GITHUB_OUTPUT
            echo "PREVIOUS_MIGRATION=$PREVIOUS_MIGRATION" >> $GITHUB_OUTPUT
          fi

      # ---------------------------------
      # Generate migration SQL (if found)
      # ---------------------------------
      - name: Set migration args
        if: steps.migrations.outputs.has_migrations == 'true'
        run: |
          if [[ "${{ steps.migrations.outputs.PREVIOUS_MIGRATION }}" == "${{ steps.migrations.outputs.LAST_MIGRATION }}" ]]; then
            echo "FROM_MIGRATION=0" >> $GITHUB_ENV
            echo "TO_MIGRATION=${{ steps.migrations.outputs.LAST_MIGRATION }}" >> $GITHUB_ENV
          else
            echo "FROM_MIGRATION=${{ steps.migrations.outputs.PREVIOUS_MIGRATION }}" >> $GITHUB_ENV
            echo "TO_MIGRATION=${{ steps.migrations.outputs.LAST_MIGRATION }}" >> $GITHUB_ENV
          fi

      - name: Generate DB migration scripts
        if: steps.migrations.outputs.has_migrations == 'true'
        run: |
          echo "⚡ Generating SQL script from $FROM_MIGRATION → $TO_MIGRATION"
          mkdir -p migrations
          dotnet ef migrations script \
            $FROM_MIGRATION $TO_MIGRATION \
            --idempotent \
            --project orders.database \
            --startup-project orders.webapi \
            --configuration Release \
            --context OrderDbContext \
            -o migrations/${TO_MIGRATION}.sql

      - uses: actions/upload-artifact@v4
        if: steps.migrations.outputs.has_migrations == 'true'
        with:
          name: db-migration-scripts
          path: migrations/


  db-apply-migrations-staging:
    needs: db-generate-migrations
    environment: staging-db   # 🔒 requires approval
    runs-on: ubuntu-latest
    if: needs.db-generate-migrations.outputs.has_migrations == 'true'
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: db-migration-scripts
          path: sql-migration-scripts/

      - name: Check DB connectivity before applying migration
        run: |
          echo "🔌 Testing database connection..."
          timeout 15 bash -c "</dev/tcp/$SQL_HOST/$SQL_PORT" \
            && echo "✅ Database is reachable." \
            || (echo "❌ Database is not reachable." && exit 1)

      - name: Build SQL Applier Docker Image
        run: |
          docker build -f $CICD_SQL/sql-applier.Dockerfile . -t sql-applier

      - name: Debug migration sql
        run: |
          echo "📂 Workspace files:"
          ls -lrta ${{ github.workspace }}
          echo "📄 Checking migration.sql:"
          file ${{ github.workspace }}/sql-migration-scripts/migration.sql || echo "migration.sql not found"

      - name: Debug Docker inputs
        run: |
          echo "SQL_HOST=${SQL_HOST}"
          echo "SQL_PORT=${SQL_PORT}"
          echo "SQL_DB=${SQL_DB}"
          echo "SQL_SA_USER=${SQL_SA_USER}"
          echo "SQL_PASS=${SQL_PASS}"
          ls -l ${{ github.workspace }}/sql-migration-scripts/migration.sql

      - name: Run SQL Applier to apply migration
        run: |
          docker run --rm \
            -e DB_HOST="${SQL_HOST},${SQL_PORT}" \
            -e DB_NAME=$SQL_DB \
            -e DB_USER=$SQL_SA_USER \
            -e DB_PASS="${SQL_PASS}" \
            -v ${{ github.workspace }}/sql-migration-scripts/migration.sql:/app/migration.sql \
            sql-applier

  # ---------------------------------
  # 4. Build & Push (push to main/master only)
  # ---------------------------------
  build-and-push:
    needs: [unit-tests, db-generate-migrations db-apply-migrations-staging]
    needs: [db-generate-migrations, db-apply-migrations-staging]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
      IMAGE_OWNER: ${{ github.repository_owner }}
      IMAGE_NAME: siva-dotnet-api
      IMAGE_TAG_SHA: ${{ github.sha }}
      IMAGE_TAG_BRANCH: ${{ github.ref_name }}-${{ github.run_number }}
    outputs: 
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.IMAGE_OWNER }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Set image tag output
        id: meta
        run: echo "image_tag=${{ env.IMAGE_TAG_SHA }}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: cicd/dotnet-api/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG_SHA }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG_BRANCH }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}:latest

  # ---------------------------------
  # 5. Deploy API (push to main/master only)
  # ---------------------------------
  deploy-api-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging
    steps:
    - name: ✅ Checkout code
      uses: actions/checkout@v4

    - name: 🔐 Set up SSH key & known_hosts
      run: |
        mkdir -p ~/.ssh
        echo "${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        ssh-keyscan -H "$REMOTE_HOST" >> ~/.ssh/known_hosts

    - name: 📤 Copy deployment files to remote server
      run: |
        ssh -i ~/.ssh/id_rsa $REMOTE_USER@$REMOTE_HOST "mkdir -p $DOTNET_API_REMOTE_APP_DIR"
        scp -i ~/.ssh/id_rsa $CICD_API/$API_COMPOSE_FILE \
            $CICD_SCRIPTS/install-docker.sh \
            $REMOTE_USER@$REMOTE_HOST:$DOTNET_API_REMOTE_APP_DIR/

    - name: 🐳 Ensure Docker is installed on remote
      run: ssh -i ~/.ssh/id_rsa $REMOTE_USER@$REMOTE_HOST "bash $DOTNET_API_REMOTE_APP_DIR/install-docker.sh"

    - name: 🚀 Deploy application
      run: |
        IMAGE="${{ needs.build-and-push.outputs.image-tag }}"
        ssh -i ~/.ssh/id_rsa $REMOTE_USER@$REMOTE_HOST << EOF
          set -e
          echo "🔐 Logging into GHCR..."
          echo "${{ secrets.GHCR_PAT }}" | sudo docker login ghcr.io -u ${{ github.repository_owner }} --password-stdin
          
          cd $DOTNET_API_REMOTE_APP_DIR
          echo "📝 Writing environment variables to .env file..."
          echo "DOTNET_IMAGE_TAG=$IMAGE" > .env
          echo "SA_PASSWORD=${{ secrets.SA_PASSWORD }}" >> .env
          
          echo "📥 Pulling image: $IMAGE"
          sudo docker compose --env-file .env -f $API_COMPOSE_FILE pull
          
          echo "🧱 Starting containers..."
          sudo docker compose --env-file .env -f $API_COMPOSE_FILE up -d
          
          echo "✅ Deployment complete."
        EOF

  db-apply-migrations-prod:
    if: needs.db-generate-migrations.outputs.has_migrations == 'true'
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production-db   # 🔒 requires approval
    steps: