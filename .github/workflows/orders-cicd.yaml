name: Orders CI/CD Pipeline

on:
  push:
    branches:
      - '**'     # Run on all branches (feature, hotfix, main, etc.)
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch: {}


env:
  # Workflow-wide defaults
  CICD_SQL: 'cicd/sql'
  CICD_API: 'cicd/api'
  API_COMPOSE_FILE: 'docker-compose-api.yaml'
  API_COMPOSE_FILE_WITHPATH: 'cicd/api/docker-compose-api.yaml'
  REMOTE_USER: 'ubuntu'
  REMOTE_APP_DIR: '/app'
  SQL_PORT: '1433'
  SQL_USER: 'sa'
  SQL_DB: 'OrdersDb'
  DOWNLOAD_MIGRATIONS: ${{ github.workspace }}/migrations


jobs:
  # ---------------------------------
  # 1. Unit Tests + Coverage
  # ---------------------------------
  unit-tests:
    runs-on: ubuntu-latest
    steps:
        - uses: actions/checkout@v4
        - uses: actions/setup-dotnet@v3
          with:
             dotnet-version: '8.0.x'
        - run: dotnet restore
        - run: sudo apt-get update && sudo apt-get install -y bc libxml2-utils

        - name: Run unit tests with coverage
          run: |
                dotnet test ./orders.test/orders.test.csproj \
                --collect:"XPlat Code Coverage" \
                --results-directory ./TestResults \
                -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=cobertura \
                -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Include="[orders.domain]*,[orders.application]*"

        - name: Install ReportGenerator
          run: |
            dotnet tool install --global dotnet-reportgenerator-globaltool
            echo "${HOME}/.dotnet/tools" >> $GITHUB_PATH

        - name: Generate coverage report
          run: |
            reportgenerator -reports:./TestResults/**/coverage.cobertura.xml \
            -targetdir:CoverageReport \
            "-reporttypes:Html;TextSummary;HtmlSummary;Cobertura;XmlSummary"

        - name: Validate 65% code coverage threshold
          run: |
            COVERAGE_FILE=$(find CoverageReport -name 'Summary.xml')
            COVERAGE_PERCENT=$(xmllint --xpath "string(//Summary/Linecoverage)" "$COVERAGE_FILE")
            echo "âœ… Code coverage: $COVERAGE_PERCENT%"
            if echo "$COVERAGE_PERCENT < 65" | bc -l | grep -q 1; then
            echo "âŒ Code coverage below threshold!"
            exit 1
            fi

        # âœ… Upload report artifact only on main/master *and only for push*
        - uses: actions/upload-artifact@v4
          if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
          with:
            name: code-coverage-report
            path: CoverageReport/

  # ---------------------------------
  # 2. Generate DB Migrations (push to main/master only)
  # ---------------------------------
  db-generate-migrations:
    needs: unit-tests
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest
    outputs:
      has_migrations: ${{ steps.migrations.outputs.has_migrations }}
    steps:
      - uses: actions/checkout@v4

      # ---------------------------------
      # Install EF Core Tools + Build Solution
      # ---------------------------------
      # - name: Install EF Core tools
      #   run: dotnet tool install --global dotnet-ef

      # - name: Add .NET tools to PATH
      #   run: echo "$HOME/.dotnet/tools" >> $GITHUB_PATH

      # Pin SDK version (reads global.json if present)
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          global-json-file: global.json  # or: dotnet-version: '8.0.x'

      # Restore the local tools (picks versions from .config/dotnet-tools.json)
      - name: Restore .NET tools
        run: dotnet tool restore

      - name: Restore dependencies
        run: dotnet restore ./orders.service.sln

      - name: Build solution
        run: dotnet build ./orders.service.sln --configuration Release --no-restore

      # ---------------------------------
      # Check for EF Core migrations
      # ---------------------------------
      - name: Get migrations
        id: migrations
        env: 
          ConnectionStrings__DefaultConnection: "Server=DummyServer;Database=DummyDb;User Id=sa;Password=DummyPassword;"
        run: |
          echo "ðŸ“‹ Checking EF Core migrations..."
          MIGRATIONS=$(dotnet ef migrations list \
            --project orders.database \
            --startup-project orders.webapi \
            --configuration Release \
            --context OrderDbContext \
            --no-build --no-connect 2>&1 \
            | grep -E '^[0-9]{14}_.+' || true)

          echo "MIGRATIONS FOUND:"
          echo "$MIGRATIONS"

          if [[ -z "$MIGRATIONS" || "$MIGRATIONS" == "No migrations were found." ]]; then
            echo "has_migrations=false" >> $GITHUB_OUTPUT
          else
            LAST_MIGRATION=$(echo "$MIGRATIONS" | tail -n 1)
            PREVIOUS_MIGRATION=$(echo "$MIGRATIONS" | tail -n 2 | head -n 1)

            echo "has_migrations=true" >> $GITHUB_OUTPUT
            echo "LAST_MIGRATION=$LAST_MIGRATION" >> $GITHUB_OUTPUT
            echo "PREVIOUS_MIGRATION=$PREVIOUS_MIGRATION" >> $GITHUB_OUTPUT
          fi

      # ---------------------------------
      # Generate migration SQL (if found)
      # ---------------------------------
      - name: Set migration args
        if: steps.migrations.outputs.has_migrations == 'true'
        run: |
          if [[ "${{ steps.migrations.outputs.PREVIOUS_MIGRATION }}" == "${{ steps.migrations.outputs.LAST_MIGRATION }}" ]]; then
            echo "FROM_MIGRATION=0" >> $GITHUB_ENV
            echo "TO_MIGRATION=${{ steps.migrations.outputs.LAST_MIGRATION }}" >> $GITHUB_ENV
          else
            echo "FROM_MIGRATION=${{ steps.migrations.outputs.PREVIOUS_MIGRATION }}" >> $GITHUB_ENV
            echo "TO_MIGRATION=${{ steps.migrations.outputs.LAST_MIGRATION }}" >> $GITHUB_ENV
          fi

      - name: Generate DB migration scripts
        if: steps.migrations.outputs.has_migrations == 'true'
        run: |
          echo "âš¡ Generating SQL script from $FROM_MIGRATION â†’ $TO_MIGRATION"
          mkdir -p migrations
          dotnet ef migrations script \
            $FROM_MIGRATION $TO_MIGRATION \
            --idempotent \
            --project orders.database \
            --startup-project orders.webapi \
            --configuration Release \
            --context OrderDbContext \
            --output "migrations/migration.sql"

          echo "ðŸ“‚ Checking generated file:"
          ls -lh migrations/

          if [ ! -f "migrations/migration.sql" ]; then
            echo "âŒ migration.sql not generated!"
            exit 1
          else
            echo "âœ… migration.sql generated successfully"
          fi

      - uses: actions/upload-artifact@v4
        if: steps.migrations.outputs.has_migrations == 'true'
        with:
          name: db-migration-scripts
          path: migrations/migration.sql
          if-no-files-found: error

  # ---------------------------------
  # 3. Apply DB Migrations to staging environment upon approval (push to main/master only)
  # ---------------------------------
  db-apply-migrations-staging:
    needs: db-generate-migrations
    if: needs.db-generate-migrations.outputs.has_migrations == 'true'
    environment: staging   # ðŸ”’ approval gate
    runs-on: ubuntu-latest    
    steps:
        - uses: actions/checkout@v4
        - name: ðŸ“‚ Prepare migrations directory
          run: mkdir -p $DOWNLOAD_MIGRATIONS
        - uses: ./.github/actions/db-apply-migrations
          with:
            sql-host: ${{ vars.REMOTE_HOST }}
            sql-port: ${{ env.SQL_PORT }}
            sql-db: ${{ env.SQL_DB }}
            sql-user: ${{ env.SQL_USER }}
            sql-pass: ${{ secrets.SA_PASSWORD }}
            cicd-sql: ${{ env.CICD_SQL }}
            runner-download-migrations: $DOWNLOAD_MIGRATIONS

  # ---------------------------------
  # 4. Build & Push (push to main/master only)
  # ---------------------------------
  build-and-push:
    needs: [unit-tests, db-generate-migrations, db-apply-migrations-staging]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest
    env:
      REGISTRY: ghcr.io
      IMAGE_OWNER: ${{ github.repository_owner }}
      IMAGE_NAME: siva-dotnet-api
      IMAGE_TAG_SHA: ${{ github.sha }}
      IMAGE_TAG_BRANCH: ${{ github.ref_name }}-${{ github.run_number }}
    outputs: 
      image_tag: ${{ steps.meta.outputs.image_tag }}
    steps:
      - name: Checkout source code
        uses: actions/checkout@v4

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ env.IMAGE_OWNER }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Set image tag output
        id: meta
        run: echo "image_tag=${{ env.IMAGE_TAG_SHA }}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: cicd/dotnet-api/Dockerfile
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG_SHA }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG_BRANCH }}
            ${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}:latest

  # ---------------------------------
  # 5. Deploy API to staging environment (push to main/master only)
  # ---------------------------------
  deploy-api-staging:
    needs: build-and-push
    runs-on: ubuntu-latest
    environment: staging
    steps:
    - name: âœ… Checkout code
      uses: actions/checkout@v4

    - name: ðŸš€ Deploy to Staging
      uses: ./.github/actions/deploy-api
      with:
        remote_host: ${{ vars.REMOTE_HOST }}
        remote_user: ${{ env.REMOTE_USER }}
        remote_app_dir: ${{ env.REMOTE_APP_DIR }}
        ssh_private_key: ${{ secrets.REMOTE_SSH_PRIVATE_KEY }}
        sa_password: ${{ secrets.SA_PASSWORD }}
        api_compose_file: ${{ env.API_COMPOSE_FILE }}
        api_compose_file_withpath: ${{ env.API_COMPOSE_FILE_WITHPATH }}
        ghcr_pat: ${{ secrets.GHCR_PAT }}
        image_tag: ${{ needs.build-and-push.outputs.image_tag }}
  
  # ---------------------------------
  # 6. Apply DB Migrations to production environment upon approval (push to main/master only)
  # ---------------------------------
  db-apply-migrations-production:
    needs: deploy-api-staging
    if: needs.db-generate-migrations.outputs.has_migrations == 'true'
    environment: production   # ðŸ”’ approval gate
    runs-on: ubuntu-latest
    steps:
        - uses: actions/checkout@v4
        - name: ðŸ“‚ Prepare migrations directory
          run: mkdir -p $DOWNLOAD_MIGRATIONS
        - uses: ./.github/actions/db-apply-migrations
          with:
            sql-host: ${{ vars.REMOTE_HOST }}
            sql-port: ${{ env.SQL_PORT }}
            sql-db: ${{ env.SQL_DB }}
            sql-user: ${{ env.SQL_USER }}
            sql-pass: ${{ secrets.SA_PASSWORD }}
            cicd-sql: ${{ env.CICD_SQL }}
            runner-download-migrations: $DOWNLOAD_MIGRATIONS

  # ---------------------------------
  # 7. Deploy API to production environment upon approval (push to main/master only)
  # ---------------------------------
  deploy-api-prod:
    needs: [deploy-api-staging, db-apply-migrations-production]
    runs-on: ubuntu-latest
    environment: production   # ðŸ”’ requires manual approval
    steps:
    - name: âœ… Checkout code
      uses: actions/checkout@v4

    - name: ðŸš€ Deploy to Production
      uses: ./.github/actions/deploy-api
      with:
        remote_host: ${{ vars.REMOTE_HOST }}
        remote_user: ${{ env.REMOTE_USER }}
        remote_app_dir: ${{ env.REMOTE_APP_DIR }}
        ssh_private_key: ${{ secrets.REMOTE_SSH_PRIVATE_KEY }}
        sa_password: ${{ secrets.SA_PASSWORD }}
        api_compose_file: ${{ env.API_COMPOSE_FILE }}
        api_compose_file_withpath: ${{ env.API_COMPOSE_FILE_WITHPATH }}        
        ghcr_pat: ${{ secrets.GHCR_PAT }}
        image_tag: ${{ needs.build-and-push.outputs.image_tag }}